1.常用算法：4个排序算法和2个查找算法
1.1.冒泡排序算法
	例如：
	初始状态：9 7 5 3 1
	第一趟：	7 5 3 1 9 (4)
	第二趟：	5 3 1 7 9 (4)
	第三趟：	3 1 5 7 9 (4)
	第四趟：	1 3 5 7 9 (4)
	结论：N个数据需要N-1趟排序,每趟需要N-1次比较
	优化
	初始状态：9 7 5 3 1 
	第一趟：	7 5 3 1 9 (4)
	第二趟：	5 3 1 7 9 (3)
	第三趟：	3 1 5 7 9 (2)
	第四趟：	1 3 5 7 9 (1)
	结论：N个数据需要N-1趟排序,每趟需要N-i次比较
	优化
	初始状态：0 7 5 3 1
	第一趟：0 5 3 1 7
	第二趟：0 3 1 5 7
	第三趟：0 1 3 5 7
	第四趟：压根么有发生数据的交换，说明排序完成
	结论：如果发现某趟排序中没有数据交换，则认为排序完成
	参考代码：sort目录
1.2.插入排序算法
	例如：
	初始状态：10 30 20 15 5 //无序的
	原始插入排序思想：5 10 15 20 30	//有序的
	思路：从无序的数列中取出数据单独放到一个有序的内存中,存放时找到自己的位置插入即可
	弊端：需要额外开辟内存空间来存储有序数列
	解决办法：无需额外开辟内存空间，在原来的内存基础上即可完成插入排序
	原地实现插入排序：
	初始状态：10 30 20 15 5 //无序的
		  5 10 15 20 30
		  5//data变量暂存被插入的数据
	思路：定义一个变量暂存被插入的数据，然后拿着被插入的数据在前面的有序数列中从后往前扫描
		找到插入的位置存放即可，注意：第一个数据无需研究，因为本身有序	
1.3.选择排序算法
	例如：
	初始值:9 7 5 3 1 //无序的
	原始想法：先额外开辟内存空间来存储有序数列
	从无序的数列中选择最小的放到有序数列中，然后再从剩余的无序数列中
	在选择一个最小的放到有序的第二个，以此类推重复选择下去直到选择完毕
	弊端：需要额外开辟内存空间来存储有序数列
	解决办法：原地完成选择排序
	初始值:9 7 5 3 1 //无序的
	       ---------
	解决：1 7 5 3 9
		-------
	      1 3 5 7 9
		  -----
	      1 3 5 7 9
		    ---
	      1 3 5 7 9
		      -
	思想：在无序数列中选择一个最下的放到无序的第一个,再从剩余无序数列中再选一个最小的
	      放到无序的第一个，依次重复下去直到剩余一个无需选择
1.4.快速排序算法
	例如：0 10 80 30 60 50 40 70 20 90 100
	思路：不管站在哪个数上去看,它左边的数小于它，它右边的数大于它
	原始实现：比如站在50来看,进行一次分组,把比50小的放左边，大的放右边，得到：
	0 10 30 40 20 50 60 80 70 90 100 //有点接近有序
	然后对50左边的数列进行再次分组，站在30来看，把比他小的放左边，大的放右边
	然后对50右边的数列进行再次分组，站在90来看，把比他小的放左边，大的放右边，得到：
	0 20 10 30 40 50 60 80 70 90 100
	依次类推，对30左边和右边继续分组，直到最后剩余一个数据或者没有数据无需分组
	对90左边和右边继续分组，直到最后剩余一个数据或者没有数据无需分组
	最后不在分组，数列必然有序
	弊端：需要额外开辟内存空间来存储有序数列
		0 10 80 30 60 50 40 70 20 90 100
50基准		0 10 30 40 20 50 60 70 90 80 100
30,90基准	0 20 10 30 40 50 60 80 70 90 100
20,80基准	10 0 20 30 40 50 70 60 80 90 100
10,70基准	0 10 20 30 40 50 60 70 80 90 100
问：如何无需分配额外内存在原地完成分组呢？
答：定义三个游标(变量，数据的下标)来实现原地分组(p=pivot=基准),具体操作流程如下：
	以50为基准分组一次
	50//pivot变量暂存基准值
	0 10 20 30 40 50 80 70 60 90 100
	              i
	              p
		      j

1.5.线性查找算法
	思路：在数列中挨个匹配要查找的数据，对数据的有序性无要求

1.6.二分查找(又称折半)
	注意：此方法使用的前提是数据必须有序
	原理：目标找60，各种砍半跟中间值比较，根据比较结果继续左边右边继续砍半找
	      10 20 30 40 50 60 80

1.7.性能分析
	平均时间复杂度：了解算法的执行时间,理想的状态研究
	算法执行时间跟很多因素相关：
	1.跟代码的实现方式相关
		宏函数/函数
	2.编程语言
		python/c
	3.编译器相关
		inline关键字
	4.硬件相关
		单核/多核
	5.操作系统：单任务/多任务
	注意：程序中只要进行大量的内存拷贝,最要命,极其浪费CPU资源
	
	冒泡排序算法：
		平均时间复杂度：O(N^2)
		空间复杂度:S(1)
		数据越多,性能越差
		对数据有序性非常敏感
		稳定排序(相同的数据在排序前和排序后的顺序没有发生改变就是稳定排序) 
	
	插入排序算法：
		平均时间复杂度：O(N^2)
		空间复杂度:S(1)
		数据越多,性能越差
		对数据有序性非常敏感 
		稳定排序 	
		优于冒泡(值的交换),插入是值的移动
	
	选择排序算法：
		平均时间复杂度：O(N^2)
		空间复杂度:S(1)
		数据越多,性能越差
		对数据有序性不敏感 
		不稳定排序 5 8 5 2 9	
		优于冒泡(值的交换)

	快速排序算法：
		平均时间复杂度：0(NlogN)	
		空间复杂度:S(1)
		不稳定排序 6 9 9 10 11
		有序敏感吗？
		













	


